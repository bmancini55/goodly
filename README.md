# goodly

Goodly is a microservice communication framework that makes microservice scale-out simple.

Goodly was designed to allow:

1. Centralized communication for all service interactions
1. Easy scale-out of individual services
1. Easy addition of new service types
1. Large messages between services without bottlenecking
1. Messages automatically routed any service
1. Service failures are expected and gracefully handled

## What Goodly Is

Goodly is a semi-opininated microservice communication framework that works with RabbitMQ as the central message broker for all services in the system.

Goodly manages the AMQP exchange creation, queue creation, and messaging routing creation. It allows service-types to listen to messages they are interested in consuming. It allows service-types to individaully scale out. It also performs data transmission without bottlenecking the message broker.

Goodly does not dictate how to compose services into a meaningful microservice architecture. You are left to your own devices to build ontop of the communication framework.

### Design

There is a lot of information on the theory for building microservices. One growing trend is the creation of event-based reactive systems. However, the information on how to actually build event-based systems is difficult to find and even fewer examples exist for tying event-based systems into a modern web architecture.

A general microservice architecture would have many different types of services that need to interact. Idealy, each of these service types could scale-out as needed. Additionally each service type could also listen to and respond to events generated by any service. 

![alt Basic Design](https://s3.amazonaws.com/goodly/design/goodly-basic.png)

Goodly follows this approach for building a scalable system.

####RabbitMQ

Goodly manages the complexity of creating the communication infrastructure for you using RabbitMQ.

The RabbitMQ implementation creates a central application exchange, called `app` by default. 

Each service type has it's own exchange named after the service.  The service exchanges are bound to the central application exchange via `fanout` so that all services are capable of receive any message (if they were inclined to do so).

Each service type has a queue that is named after the service.  The queue gets bound to the service's exchange via `topics` that the service listens to. This allows the individaul service-type to only receieve messages filtered to that service.  Using `prefetch` the service-types pull data from their queue in a round-robin fashion to equally distribute work between the instances of that type.

![alt Rabbit](https://s3.amazonaws.com/goodly/design/goodly-rabbit.png)


####Message Flow

What makes Goodly different from a standard implementation of RabbitMQ is that data is not actually transmitted through RabbitMQ. Instead direct communication is made through HTTP requests between individaul service nodes. RabbitMQ becomes a messaging bus and not a tranmission vehicle.

This is an example of a service with multiple instances emitting an event that two other services care about.
![alt Rabbit](https://s3.amazonaws.com/goodly/design/goodly-transmission.png)

This communication mechanism means that any service can request data for an event (as both B and C do in this example).  If all data requests went back to the original Service A instance, it could create a network bottleneck on that machine. The transmission of data requets events into Service A's queue, means that the data requests are handled in round robin thus preventing bottlenecks for any given machine.


#### Error Handling


## Getting Started

Refer to the full example at https://www.github.com/bmancini55/goodly-example.

Initialize the service by configuring the caching, transport and starting the broker.
```javascript
import goodly from 'goodly';

// initialize the service
const ms = goodly({ name: 'documents' });

// initialize the caching mechanism
await ms.set('cache', goodly.redisCache({ redisUrl: process.env.REDIS }));

// initialize the transportation mechanism
await ms.set('transport', goodly.httpTransport({ httpHost: process.env.HTTPHOST }));

// start the service
await ms.start({ brokerPath: process.env.RABBIT });
```

Now you can bind an event handler
```javascript
// binding a listener for an event
await ms.on('document.uploaded', documentUploaded);
```

The handler method accepts a context and a bound emit event that will keep the correlation ID.  This allows the handler to execute without scoping (this) issues.  Additionally, handlers are executed as a middleware pipeline matching the event.  This allows event interception to occur.
```javascript
async function documentUploaded(data, { ms, emit }) {

  // do something with the record
  let result  = doSomethingWithRecord(data);

  // emit preview record
  emit('document.available', result);
}
```

## API




