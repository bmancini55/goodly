# goodly

Goodly is a microservice communication framework that makes microservice scale-out simple.

Goodly was designed to allow:

1. Centralized communication for all service interactions
1. Easy scale-out of individual services
1. Easy addition of new service types
1. Large messages between services without bottlenecking
1. Messages automatically routed any service
1. Service failures are expected and gracefully handled

## What Goodly Is

Goodly is a semi-opininated microservice communication framework that works with RabbitMQ as the central message broker for all services in the system.

Goodly manages the AMQP exchange and queue creation as well as the bindings to allow various service types to listen to message they care about.  It allows those service-types to individaully scale out as desired as well.  It also performs the data transmission when emitting an event to allow large data payloads without bottlenecking the message broker.

Goodly does not dictate how to compose serices into a meaningful microservice architecture. As such, you are left to your own devices to build ontop of the communication framework.

### Design

There is a ton of information on the theory for building microservices. The creation of event-based systems has increased in popularity. However, the information on how to actually build event-based systems is difficult to find and even fewer examples exist for tieing event-based systems into a modern web architecture.

A first pass at building microservices with RabbitMQ would likely consider individual service that can scale-out as needed. It would consider many different types of services that can be created. Because messaging is centralized, each service-type could also listen and respond to any events generated by the system. 

![alt Basic Design](https://s3.amazonaws.com/goodly/design/goodly-basic.png)

Goodly follows this approach for building a scalable system.

####RabbitMQ

Goodly manages the complexity of creating the communication infrastructure for you using RabbitMQ.

The RabbitMQ implementation creates a central application exchange, called `app` by default. 

Each service has it's own exchange named after the service.  The service exchanges are bound to the central application exchange via `fanout` so that all services can receive any message.

Lastly, each service has queue that is named after the service.  The queue gets bound to the service-exchange via `topics` that the service listens to.  

![alt Rabbit](https://s3.amazonaws.com/goodly/design/goodly-rabbit.png)

####Message Flow

What makes Goodly different than a standard implementation of RabbitMQ is that data is not actually transmitted through RabbitMQ.  Instead direct communication is made through HTTP requests between individaul service nodes. RabbitMQ becomes a messaging bus and not a tranmission vehicle.

This is an example of a service with multiple instances emitting an event that two other services care about.
![alt Rabbit](https://s3.amazonaws.com/goodly/design/goodly-transmission.png)


## Getting Started

Initialize the service by configuring the caching, transport and starting the broker.
```javascript
import goodly from 'goodly';

// initialize the service
const ms = goodly({ name: 'documents' });

// initialize the caching mechanism
await ms.set('cache', goodly.redisCache({ redisUrl: process.env.REDIS }));

// initialize the transportation mechanism
await ms.set('transport', goodly.httpTransport({ httpHost: process.env.HTTPHOST }));

// start the service
await ms.start({ brokerPath: process.env.RABBIT });
```

Now you can bind an event handler
```javascript
// binding a listener for an event
await ms.on('document.uploaded', documentUploaded);
```

The handler method accepts a context and a bound emit event that will keep the correlation ID.  This allows the handler to execute without scoping (this) issues.  Additionally, handlers are executed as a middleware pipeline matching the event.  This allows event interception to occur.
```javascript
async function previewsUploaded(data, { ms, emit }) {

  // do something with the record
  let result  = doSomethingWithRecord(data);

  // emit preview record
  emit('document.available', result);
}
```

## API




